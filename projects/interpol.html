<!DOCTYPE html
	PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
<title>Interpolation and Symbol Elimination</title>
<link href="../vampire.css" rel="StyleSheet" type="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
</head>
<body>
<table style="border-collapse:collapse"><tr>
<script src="../scripts/nav.js"></script>
<td class="content"> <h1>Interpolation and Symbol Elimination</h1> <style>.left {color:green}
             .right {color:#C58917}</style> <div style="width:50%;float:right;margin-bottom:5pt"><b>Note:</b> special thanks are to <a href="http://www.cse.chalmers.se/~laurako/">Laura Kovacs</a> who contributed both to the work described in this page and the page content.</div> <p style="clear:right">Vampire implements two new features: <b>interpolation</b> and <b>symbol elimination</b>
         described in the following papers.</p> <div class="publist"><li class="pub"><span><a href="http://www.cse.chalmers.se/~laurako/">Laura Kovacs</a>, <a href="http://www.voronkov.com/">Andrei Voronkov</a></span>. <span class="ptitle"><a href="http://dx.doi.org/10.1007/978-3-642-00593-0_33">Finding Loop Invariants for Programs over Arrays Using a Theorem Prover</a></span>. <span class="conf"><a href="http://www.informatik.uni-trier.de/~ley/db/conf/fase/fase2009.html">FASE 2009</a></span></li> <li class="pub"><span><a href="http://www.cse.chalmers.se/~laurako/">Laura Kovacs</a>, <a href="http://www.voronkov.com/">Andrei Voronkov</a></span>. <span class="ptitle"><a href="http://dx.doi.org/10.1007/978-3-642-02959-2_17">Interpolation and Symbol Elimination</a></span>. <span class="conf"><a href="http://www.informatik.uni-trier.de/~ley/db/conf/cade/cade2009.html">CADE 2009</a></span></li></div> <p>Both features have been implemented using <b>colored symbols</b> and <b>colored formulas</b>,
         explained below.</p> <h2>Interpolation</h2> <p>In the original definition of Craig, an <span class="def">interpolant</span> of
         two formulas <span class="math">L</span> and <span class="math">R</span> is any
         formula <span class="math">I</span> such that</p> <ol><li>both <span class='math'>&#8872; L &#8835; I</span>
             and <span class='math'>&#8872; I &#8835; R</span> (that is,
             <span class='math'>I</span> is implied by <span class='math'>L</span>
             and implies <span class='math'>R</span>).</li> <li>Every symbol occurring in <span class="math">I</span> also occurs both in
             <span class="math">L</span> and <span class="math">R</span>.</li></ol> <p>Craig proved that, if <span class="math">R</span> is implied by
         <span class="math">L</span>, then such an interpolant exists.</p> <p>However, for applications in verification and invariant generation this definition
         is too restrictive. Firstly, we are normally interested in reasoning modulo a theory
         <span class="math">T</span> (for simplicity we assume that a
         <span class="def">theory</span> any set of formulas).
         Secondly, we may allow theory symbols and some other symbols occur in the
         interpolant.</p> <p>We capture this more general notion of interpolant by using logical consequence
         modulo theory and by coloring symbols. We assume to have
         two <span class="def">colors</span>, the <span class="left">left</span>
         and the <span class="right">right</span> color. Some symbols may be colored in
         <span class="left">left</span> and some in <span class="right">right</span> (but
         not in both), and some symbols may be <span class="def">transparent</span>, that is,
         have no color. We assume the following properties:</p> <ol><li>symbols colored in <span class="left">left</span> may only occur in
             <span class="math">L</span>;</li> <li>symbols colored in <span class="right">right</span> may only occur in
             <span class="math">R</span>;</li> <li>all symbols occurring in the theory are transparent</li></ol> <p>We call an <span class="def">interpolant</span> of <span class="math">L</span> and
         <span class="math">R</span> any formula <span class="math">I</span> such that</p> <ol><li>both <span class='math'>&#8872;<sub>T</sub> L &#8835; I</span>
             and <span class='math'>&#8872;<sub>T</sub> I &#8835; R</span>.</li> <li><span class="math">I</span> is transparent, that is, consists only of transparent
             symbols.</li></ol> <p>It is easy to see that an interpolant in the sense of Craig is captured by this
         definition: to this end make the theory empty, color all symbols occurring in
         <span class="math">L</span> in <span class="left">left</span> and all symbols
         occurring in <span class="math">R</span> in <span class="right">right</span>.</p> <p>There is a similar notion of <span class="def">reverse interpolant</span>
         of <span class="math">L</span>: it is any formula <span class="math">I</span> such that</p> <ol><li>both <span class='math'>&#8872;<sub>T</sub> L &#8835; I</span>
             and <span class='math'>&#8872;<sub>T</sub> I &amp; R &#8835; &#8869;</span>.</li> <li><span class="math">I</span> is transparent, that is, consists only of transparent
             symbols.</li></ol> <p>Closely related to our definitions is a concept of a
         <span class='def'>well-colored derivation</span>: this is a derivation in which no
         inference contains clauses of both colors. Paper [2] gives an algorithm for building
         an interpolant of <span class='math'>L</span> and <span class='math'>R</span>
         from a well-colored proof of <span class='math'>L &#8835; R</span>. Vampire implements
         well-colored proofs and generation of interpolants from such proofs.</p> <p>To make Vampire generate a well-colored proof and compute an interpolant we should
         be able to define the following:</p> <ol><li>symbol colors</li> <li>which part of the input relates respectively to <span class='math'>L</span>,
             <span class='math'>R</span>, and the theory <span class='math'>T</span>.</li></ol> <h3>Example 1</h3> <p>The following examples shows how we can request Vampire generate well-colored
         proofs and interpolants using Vampire-specific extensions
         to the TPTP syntax. In this example we ask Vampire to generate an interpolant for
         <span class='math'>q(f(a)) &amp; &#172;q(f(b)) &#8835; &#8707;v(v &#8800; c)</span>.
         We use TPTP comments (beginning with the symbol
         "<span class='comment'>%</span>") to explain the input.</p> <div class="codebox"><code class="code"><span class="comment">% request to generate an interpolant</span><br />vampire(option,show_interpolant,on).<br /><span class="comment">% symbol coloring</span><br />vampire(symbol,predicate,q,1,<span class="left">left</span>).<br />vampire(symbol,function,f,1,<span class="left">left</span>).<br />vampire(symbol,function,a,0,<span class="left">left</span>).<br />vampire(symbol,function,b,0,<span class="left">left</span>).<br />vampire(symbol,function,c,0,<span class="right">right</span>).<br /><span class="comment">% formula L</span><br />vampire(left_formula).<br />&nbsp;&nbsp;fof(fA,axiom, q(f(a)) &  ~q(f(b)) ).<br />vampire(end_formula).<br /><span class="comment">% formula R</span><br />vampire(right_formula).<br />&nbsp;&nbsp;fof(fB,conjecture, ?[V]: V != c).<br />vampire(end_formula).</code></div> <p>Vampire outputs the following:</p> <div class="replybox"><code class="code">17. $false (2:0) [resolution 16,5]<br />5. q(f(a)) (0:3) [CNF transformation 3]<br />16. ~q(f(X0)) (2:3) [superposition 6,8]<br />8. X0 = X1 (1:3) [superposition 7,7]<br />7. c = X0 (0:3) [CNF transformation 4]<br />6. ~q(f(b)) (0:3) [CNF transformation 3]<br />4. ! [X0] : c = X0 [ennf transformation 2]<br />2. ~? [X0] : c != X0 [negated conjecture]<br />3. q(f(a)) & ~q(f(b)) [ennf transformation 1]<br />1. q(f(a)) & ~q(f(b)) [input]<br />Interpolant: ~! [X1,X0] : X0 = X1</code></div> <p>That is, it finds the interpolant
         <span class='math'>&#172;&#8704;x&#8704;y(x=y)</span>.
         Note that if we remove color declarations from the input, then Vampire
         will generate a different refutation:</p> <div class="codebox"><code class="code">fof(fA,axiom, q(f(a)) &  ~q(f(b)) ).<br />fof(fB,conjecture, ?[V]: V != c).</code></div> <div class="replybox"><code class="code">10. $false (0:0) [subsumption resolution 9,8]<br />8. q(c) (0:2) [forward demodulation 5,7]<br />7. c = X0 (0:3) [CNF transformation 4]<br />5. q(f(a)) (0:3) [CNF transformation 3]<br />9. ~q(c) (0:2) [forward demodulation 6,7]<br />6. ~q(f(b)) (0:3) [CNF transformation 3]<br />3. q(f(a)) & ~q(f(b)) [ennf transformation 1]<br />1. q(f(a)) & ~q(f(b)) [input]<br />4. ! [X0] : c = X0 [ennf transformation 2]<br />2. ~? [X0] : c != X0 [negated conjecture]</code></div> <h3>Example 2</h3> <p>This example uses a theory: a simple axiomatisation of arithmetic with the greater-than
         relation <tt>greater</tt> and successor function <tt>s</tt>. Essentially, in this example
         <span class='math'>L</span> is <span class='math'>q &#8805; c &#8805; p &amp; f(c)=1</span>
         and <span class='math'>R</span> is <span class='math'>p &#8805; d &#8805; q &amp; f(d)=0</span></p> <div class="codebox"><code class="code"><span class="comment">% request to generate an interpolant</span><br />vampire(option,show_interpolant,on).<br /><span class="comment">% symbol coloring</span><br />vampire(symbol,function,c,0,<span class="left">left</span>).<br />vampire(symbol,function,d,0,<span class="right">right</span>).<br /><span class="comment">% theory axioms</span><br />fof(greater1,axiom,<br />&nbsp;&nbsp;&nbsp;&nbsp;greater(s(X),X)).<br />fof(greater2,axiom,<br />&nbsp;&nbsp;&nbsp;&nbsp;greater(X,Y) => X != Y).<br />fof(greater3,axiom,<br />&nbsp;&nbsp;&nbsp;&nbsp;~greater(X,Y) => (greater(Y,X) | X = Y) ).<br />fof(greater_transitive1,axiom,<br />&nbsp;&nbsp;&nbsp;&nbsp;greater(X,Y) & greater(Y,Z) => greater(X,Z)).<br />fof(greater_transitive2,axiom,<br />&nbsp;&nbsp;~greater(X,Y) & ~greater(Y,Z) => ~greater(X,Z)).<br /><span class="comment">% formula L</span><br />vampire(left_formula).<br />&nbsp;&nbsp;fof(fA,hypothesis, ~greater(p,c) &  ~greater(c,q) & f(c) = s(zero) ).<br />vampire(end_formula).<br /><span class="comment">% formula R</span><br />vampire(right_formula).<br />&nbsp;&nbsp;fof(fB,hypothesis, ~greater(q,d)  &  ~greater(d,p) & f(d) = zero ).<br />vampire(end_formula).</code></div> <p>Vampire generates the following interpolant.</p> <div class="replybox"><code class="code">(~greater(p,q) | ~greater(p,q)) & (~greater(p,q) | ~greater(p,q)) & (~greater(p,q) | ~greater(p,q)) & (~greater(p,q) | ~greater(p,q)) & (greater(q,p) | s(zero) = f(p)) & (~greater(p,q) | ~greater(p,q)) & (~greater(p,q) | ~greater(p,q)) & (~greater(p,q) | ~greater(p,q)) & (~greater(p,q) | ~greater(p,q)) & (greater(q,p) | s(zero) = f(p)) & (~greater(p,q) | ~greater(p,q)) & (~greater(p,q) | ~greater(p,q)) & (~greater(p,q) | ~greater(p,q)) & (~greater(p,q) | ~greater(p,q)) & (greater(q,p) | s(zero) = f(p))</code></div> <p>This interpolant is equivalent to the formula
         <span class='math'>q &#8805; p &amp; f(p)=1</span>.</p> <h3>More Examples</h3> <p>More examples on computing interpolants with Vampire  <a href="interpolation_examples.zip">can be found here.</a>  Each example is given in the TPTP syntax, and hence can be
        immediately fed into Vampire.</p> <h2>Symbol Elimination</h2> <p>Symbol elimination can be used to generate loop invariants automatically, as described
         in paper [1]. The idea of invariant generation is as follows.</p> <ol><li>We generate loop properties using a language that contains program variables
             and some additional symbols. These symbols are required to express loop properties
             that are not expressible using loop variables. For example, we may introduce
             the loop counter as an additional constant.</li> <li>We run a saturation theorem prover to eliminate the extra symbols. That is,
             the prover should generate consequences of the initial formulas not containing
             extra symbols. These consequences are loop invariants.</li></ol> <p>To make Vampire eliminate symbols, we run it in the
          <span class='def'>symbol-eliminating mode</span>. We declare the symbols to be
          eliminated colored. For the
          purpose of symbol elimination, a single color is sufficient. Here is an example
          showing how to make Vampire eliminate symbols.</p> <div class="codebox"><code class="code"><br /><span class="comment">% Turn on the symbol elimination mode</span><br />vampire(option,show_symbol_elimination,on).<br /><span class="comment">% Some other options</span><br />vampire(option,naming,32000).<br />vampire(option,splitting,off).<br />vampire(option,time_limit,10).<br /><span class="comment">% symbols to eliminate</span><br />vampire(symbol,function,n,0,left).<br />vampire(symbol,function,b,1,left).<br />vampire(symbol,function,a,1,left).<br />vampire(symbol,function,aa,2,left).<br />vampire(symbol,predicate,updA,2,left).<br />vampire(symbol,predicate,updA,3,left).<br />vampire(symbol,predicate,iter,1,left).<br /><span class="comment">% skip-symbols. If a symbol-eliminating inference consists only</span><br /><span class="comment">% skip-symbols, do not put it. Normally the skip symbols are the theory symbols</span><br />vampire(symbol,predicate,geq,2,skip).<br />vampire(symbol,predicate,greater,2,skip).<br />vampire(symbol,function,s,1,skip).<br />vampire(symbol,function,zero,0,skip).<br />vampire(symbol,function,a,0,skip).<br />vampire(symbol,function,b,0,skip).<br />vampire(symbol,function,m,0,skip).<br /><span class="comment">% the problem</span><br />fof(geq1,axiom,<br />&nbsp;&nbsp;&nbsp;&nbsp;geq(X,Y) <=> greater(X,Y) | X = Y).<br />fof(geq2,axiom,<br />&nbsp;&nbsp;&nbsp;&nbsp;greater(X,Y) => X != Y).<br />fof(geq_transitive,axiom,<br />&nbsp;&nbsp;&nbsp;&nbsp;geq(X,Y) & geq(Y,Z) => geq(X,Z)).<br />fof(greater1,axiom,<br />&nbsp;&nbsp;&nbsp;&nbsp;greater(s(X),X)).<br />fof(greater2,axiom,<br />&nbsp;&nbsp;&nbsp;&nbsp;geq(X,s(Y)) <=> greater(X,Y)).<br />fof(recurrence1,hypothesis,<br />&nbsp;&nbsp;&nbsp;&nbsp;a(I) = I).<br />fof(recurrence2,hypothesis,<br />&nbsp;&nbsp;&nbsp;&nbsp;b(I) = I).<br />fof(recurrence3,hypothesis,<br />&nbsp;&nbsp;&nbsp;&nbsp;geq(m,b) | greater(zero,m)).<br />fof(poly,hypothesis,<br />&nbsp;&nbsp;&nbsp;&nbsp;a = b).<br />fof(recurrence3,hypothesis,<br />&nbsp;&nbsp;&nbsp;geq(a,zero)).<br />fof(recurrence4,hypothesis,<br />&nbsp;&nbsp;&nbsp;geq(b,zero)).<br />fof(recurrence5,hypothesis,<br />&nbsp;&nbsp;&nbsp;geq(m,b)).<br />fof(recurrence6,hypothesis,<br />&nbsp;&nbsp;&nbsp;geq(m,a)).<br />fof(ini_a,hypothesis,<br />&nbsp;&nbsp;&nbsp;&nbsp;a(zero) = zero).<br />fof(ini_b,hypothesis,<br />&nbsp;&nbsp;&nbsp;&nbsp;b(zero) = zero).<br />fof(final_a,hypothesis,<br />&nbsp;&nbsp;&nbsp;&nbsp;a(n) = a).<br />fof(final_b,hypothesis,<br />&nbsp;&nbsp;&nbsp;&nbsp;b(n) = b).<br />fof(ini_aa,hypothesis,<br />&nbsp;&nbsp;&nbsp;&nbsp;aa(zero) = aa0).<br />fof(final_aa,hypothesis,<br />&nbsp;&nbsp;&nbsp;&nbsp;aa(n,P) = aa(P)).<br />fof(def_update_predicate_A1,hypothesis,<br />&nbsp;&nbsp;&nbsp;&nbsp;updA(I,P) <=> (iter(I) & P = a(I) & greater(m,b(I)))).<br />fof(def_update_predicate_A2,hypothesis,<br />&nbsp;&nbsp;&nbsp;&nbsp;updA(I,P,V) <=><br />&nbsp;&nbsp;&nbsp;&nbsp;(iter(I) & P = a(I) & greater(m,b(I)) & V = bb(b(I))) ).<br />fof(stability_A,hypothesis,<br />&nbsp;&nbsp;&nbsp;&nbsp;! [I] : (iter(I) => ~updA(I,P)) => aa(P) = aa0(P)).<br />fof(last_update_A,hypothesis,<br />&nbsp;&nbsp;&nbsp;&nbsp;updA(I,P,V) &<br />&nbsp;&nbsp;&nbsp;&nbsp;! [J] : (greater(J,I) => ~updA(J,P)) => aa(P) = V).<br />fof(iter_definition,axiom,<br />&nbsp;&nbsp;&nbsp;&nbsp;! [I] : (iter(I) <=> ( geq(I,zero) & greater(n,I) ))).<br />fof(gas,hypothesis,<br />&nbsp;&nbsp;&nbsp;&nbsp;! [I] : (iter(I) & greater(m,b(I))) =><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(aa(s(I),a(I)) = bb(b(I)) &<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a(s(I)) = s(a(I)) & <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b(s(I)) = s(b(I))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)).</code></div> <h3>More Examples</h3> <p>More examples on symbol elimination with Vampire  <a href="symbol_elimination_examples.zip">can be found here.</a>  For each example, we list its source code (in C), its encoding in TPTP,
        the obtained set of symbol eliminating inferences, and a minimised
        set of symbol eliminating inferences.</p></td></tr></table>
</body>
</html>
